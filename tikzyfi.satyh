@require: gr
@require: base/base
@require: base/tree-map
@require: base/tree-set
@require: base/ord
@require: base/length
@require: base/string
@require: base/list-ext
@require: base/option-ext
@require: base/fn
@require: base/tuple
@require: Color

@import: utils
@import: dlist
@import: algorithms

type direction 
  = North | South | East | West 
  | NorthEast | NorthWest
  | SouthEast | SouthWest
  | Center
type shape = Plain | Circle | Rect
type node-style = (|
  shape: shape;
  fill-color: color;
  stroke-color: color;
  padding: length;
  name: string option;
|)
type config = (|unit-length: length; default-node-style : node-style|)
type matrix-config = (|
  unit-length: length;
  matrix-name: string option;
  default-node-style : node-style;
|)
type position = Absolute of point | Relative of direction * string

type matrix-node = (|name : string option; shape : shape;|)

module TikZyFi : sig
  type node
  type element
  val matrix: (node list) list -> element
  val node-at: (node-style -> node-style) ?-> position -> inline-text -> element
  val arrow: position -> position -> element
  val empty: node
  val node: (node-style -> node-style) list ?-> inline-text -> node
  val fc: color -> node-style -> node-style
  val lc: color -> node-style -> node-style
  val named: string -> node-style -> node-style
  val circle: node-style -> node-style
  val rect: node-style -> node-style
  val plain: node-style -> node-style
  val default: config
  val default-matrix: matrix-config
  val default-node-style: node-style
  type env
  % val dfs: env -> ((string list) list) option
  direct \matrix: [matrix-config?; (node list) list] inline-cmd
end = struct
  open Gr
  open Algorithms

  type extent = (|width : length; height: length; depth: length|)
  let extent-of inl = 
      let (w, h, d) = get-natural-metrics inl
      in (|width = w; height = h; depth = d|)

  let default-node-style: node-style = 
    (|shape = Plain; padding = 5pt
    ; stroke-color = Color.black
    ; fill-color = Color.white
    ; name = None
    |)

  let named name = fun opt -> (|opt with name = Some(name)|)

  let len-ord = Ord.make 
        (fun x y -> (if x <' y
          then Lt
          else if x >' y then Gt else Eq)
        )
  let default : config = (|unit-length = 1cm ; default-node-style = default-node-style |)

  let fc c = fun x -> (| x with fill-color = c |)
  let lc c = fun x -> (| x with stroke-color = c |)
  let circle = fun x -> (| x with shape = Circle|)
  let rect = fun x -> (| x with shape = Rect|)
  let plain = fun x -> (| x with shape = Plain|)

  let graphics-extent grs = 
    let ((min-x, min-y), (max-x, max-y)) = 
        Option.unwrap-or ((0pt, 0pt), (0pt, 0pt))
          (fold-map
            None
            (fun l r ->
              (match (l, r) with
              | (None, None) -> None
              | (Some(bb), None) -> Some(bb)
              | (None, Some(bb)) -> Some(bb)
              | (Some((xmin, ymin), (xmax, ymax)), Some((xmin1, ymin1), (xmax1, ymax1))) ->
                  Some(
                    (Length.min xmin xmin1, Length.min ymin ymin1),
                    (Length.max xmax xmax1, Length.max ymax ymax1)
                  )
              )
            ) 
            (fun gr -> Some(get-graphics-bbox gr))
            grs
          )
    in (|width = max-x -' min-x; height = max-y -' min-y; depth = 0pt |)

  let render-graphics grs =
    let extent = graphics-extent grs
    in  inline-graphics extent#width extent#height extent#depth
          (fun pt -> List.map (shift-graphics pt) grs)

  let default-pads = (3pt, 3pt, 3pt, 3pt)

  type dx = length
  type dy = length
  % Maps direction to the coordinate relative to the node origin.
  % TODO: Use envelopes (ala diagrams in Haskell) for more fine-grained tracing
  type locator = direction -> dx * dy

  type node-geometry = (|locator: locator|)

  let plain = fun style -> (|style with shape = Plain|)

  let empty-style: node-style = (|default-node-style with padding=0pt; shape=Plain|)
  type node = Node of (|style : node-style -> node-style; body: inline-text|)
  let empty = Node (|style = Fn.const empty-style; body = {}|)
  let node ?:styler body = Node (|style = Option.map-or Fn.id Utils.apps styler; body = body|)
  type raw-node = (|position: position; style: node-style; body: inline-text|)

  type element 
    = Matrix of (node list) list
    | ANode of raw-node
    | Arrow of position * position

  let matrix rows = Matrix rows
  let node-at ?:styler position body = 
        ANode 
          (|position = position
          ; style = Option.unwrap-or Fn.id styler default-node-style
          ; body = body
          |)
  let arrow from to = Arrow (from, to)

  let pads-of style = (style#padding, style#padding, style#padding, style#padding)

  let locate-rect extent dir =
      let h = extent#height +' extent#depth in
      let w = extent#width in
        match dir with
        | Center -> (0pt, 0pt)
        | North  -> (0pt, extent#height)
        | South -> (0pt, 0pt -' extent#depth)
        | East  -> (w *' 0.5, 0pt)
        | West  -> (w *' (-0.5), 0pt)
        | NorthEast -> (w *' 0.5, h *' 0.5)
        | NorthWest -> (w *' (-0.5), h *' 0.5)
        | SouthEast -> (w *' 0.5, h *' (-0.5))
        | SouthWest -> (w *' (-0.5), h *' (-0.5))

  let locate-plain = locate-rect
  let locate-circle extent dir =
    let r = extent#width *' 0.5 in
    let pi = 3.141592653589793238462
    in let deg = 
        match dir with
        | Center -> None
        | North -> Some(pi /. 2.0)
        | South -> Some(pi /. (-2.0))
        | East -> Some(0.0)
        | West -> Some(pi)
        | NorthEast -> Some(pi /. 4.0)
        | NorthWest -> Some(3.0 *. pi /. 4.0)
        | SouthEast -> Some(pi /. (-4.0))
        | SouthWest -> Some(5.0 *. pi /. 4.0)
    in match deg with
       | None  -> (0pt, 0pt)
       | Some(deg) -> (r *' cos deg, r *' sin deg)

  let to-geometric-node-with l ib = (|locator = l (extent-of ib )|)

  let draw-node-shape-with f style = 
      inline-frame-outer (pads-of style) 
      (fun pt w h d ->
        (let circle = f style pt w h d
        in [ stroke 1pt style#stroke-color circle 
           ; fill style#fill-color circle 
          ]
        )
      )

  let circled = 
    draw-node-shape-with
      (fun style (x, y) w h d ->
        (let center = (x +' w *' 0.5, y +' (h -' d) *' 0.5) 
        in let r = Length.max w (h -' d) *' 0.5 +' style#padding
        in Gr.circle center r
        )
      )

  let rectify = 
    draw-node-shape-with
    (fun style (x, y) w h d ->
      ( let llc = (x, y -' d)
        in let urc = (x +' w, y +' h)
        in Gr.rectangle llc urc
      )
    )

  let draw-node ctx cfg (Node node) =
    let style = node#style cfg#default-node-style in
    let it = node#body in 
    let pads = (style#padding, style#padding, style#padding, style#padding) 
    in match style#shape with
            | Plain -> read-inline ctx it
            | Rect -> rectify style (read-inline ctx it)
            | Circle -> circled style (read-inline ctx it)

  let process-node ctx cfg (Node node) =
    let style = node#style cfg#default-node-style in
    let it = node#body in 
    let pads = (style#padding, style#padding, style#padding, style#padding)  in
    let node = match style#shape with
        | Plain   -> read-inline ctx it
        | Rect    -> rectify style (read-inline ctx it)
        | Circle  -> circled style (read-inline ctx it)
    in let loc = match style#shape with
        | Plain   -> to-geometric-node-with locate-plain node
        | Rect    -> to-geometric-node-with locate-rect node
        | Circle  -> to-geometric-node-with locate-circle node
    in (node, (style, loc))

  let draw-node-at (xstart, ystart) ib =
    (let ext = extent-of ib
      in let center-x = xstart -' ext#width *' 0.5
      in let center-y = ystart
      in let center = (center-x, center-y)
      in draw-text center ib
    )

  let pair-app app app2 = fun (l, r) (l1, r1) -> (app l l1, app2 r r1)

  let place-matrix-nodes ctx cfg xss =
    let dx = cfg#unit-length in
    let dy = cfg#unit-length in
    let ibs = List.map (List.map (process-node ctx cfg)) (List.reverse xss) in
    let extents: (extent list) list = 
          List.map (List.map (Fn.compose extent-of Pair.fst)) ibs
    in let xoffs: length list = 
          prescan-left
            (fun off w -> off +' dx +' w)
            0pt
              (List.map 
                (Fn.compose (Option.unwrap-or 0pt)
                  (Fn.compose
                    (List.max len-ord)
                    (List.map (fun ext -> ext#width))
                  )
                )
                (pad-transpose (|width=0pt;height=0pt;depth=0pt|) extents)
              )
    in let yoffs: length list =
          prescan-lefti
            (fun yn off ht -> off +' dy +' ht)
            0pt
            (List.map 
              (Fn.compose (Option.unwrap-or 0pt)
                (Fn.compose (List.max len-ord) 
                  (List.map (fun ext -> ext#height))
                )
              )
              extents
            )
    in let (ents, dic-dl) = 
          fold-zipi 
            (DList.empty, DList.empty) (pair-app DList.append DList.append)
            (fun yn ystart ->
              fold-zipi 
                (DList.empty, DList.empty) (pair-app DList.append DList.append)
                (fun xn xstart (ib, (style, loc)) ->
                  (
                    let nodes = DList.singleton (draw-node-at (xstart, ystart) ib)
                    in let dic = match (style#name, cfg#matrix-name) with
                        | (Some(name), _) -> DList.singleton (name, loc)
                        | (None, Some(mat)) -> 
                            DList.singleton 
                              (mat ^ `-` ^ arabic xn ^ `-` ^ arabic yn, loc)
                        | _ -> DList.empty
                    in (nodes, dic)
                  )
                )
                xoffs
            )
            yoffs
            ibs
    in let dic = TreeMap.of-list String.ord (DList.to-list dic-dl)
    in (DList.to-list ents, dic)

  let make-diagram ctx paths = []
  let as-matrix-config: config -> matrix-config = fun cfg ->
      (|default-node-style = cfg#default-node-style
      ; unit-length = cfg#unit-length
      ; matrix-name = None
      |)
  let default-matrix = as-matrix-config default

  

  let-inline ctx \matrix ?:cfg0 xss =
    let cfg = Option.unwrap-or (as-matrix-config default) cfg0
    in let (grs, dic) = place-matrix-nodes ctx cfg xss
    in render-graphics grs

  type env = string node TreeMap.t
  % let target-of (Node node) =
  %       Option.and-then 
  %         (fun pos -> 
  %           (match pos with
  %           | Relative (_, p) ->  Some(p)
  %           | _ -> None
  %           )
  %         ) node#position
  % let dfs = topsort String.ord target-of
end
